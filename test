
# 자기소개
안녕하세요 저는 프론트엔드 개발을 하고 있는 임재혁입니다.
저는 블록체인 게임 회사에서 플렛폼을 담당하는 프론트엔드 개발자입니다.
프로젝트는 next.js ,typeScript, redux-toolkit , react-query로 개발이 진행이 되었고
저는 주로 캐릭터 아이템 인벤토리와 DAO , Admin사이트를 담당을 했씁니다.
인턴쉽을 진행하면서 블로그를 next-js 와 typescript를 리뉴얼 하는 작업을 진행을 했습니다.
짧지만 그러한 경험을 바탕으로 비전있고 도전적이라 생각하는 아더 월드에서 함께 하고 싶어서 지원하게 되었습니다.

# 프로젝트 소개
luxon이라는 프로젝트는 nft, staking,quest , marketplace등의 기능이 있는 플랫폼입니다.
제가 담당한 부분에 대해서 말씀드리겠습니다.
가독성과 유지보수를 위해서 view를 담당하는 부분 , components, 데이터를 패칭하는 부분 ,
클라이언트 상태를 관리하는 부분을
각각 기능과 목적에 따라서 나눠 개발을 진행을 했는데요
인턴쉽을 경험할떄 앞서 말씀 드린부분을 고려를 많이 하지 않았다 보니 코드가 조잡스러워진 경향이 있어서
룩손이라는 프로젝트를 할때에는 이 부분에 대해서 신경을 쓰면서 개발을 진행했습니다.

캐릭터와 아이템 인벤토리는 데이터를 파싱,페이지네이션 , 필터의 기능이 있는데요
먼저 react-query의 useQuery로 서버의 api 를 파싱을 하는 
usegetInventory라는 hooks를 만들어서 개발하였습니다.
페이지네이션은 전체 아이템 개수와 Data를 Array로 Response해주었고.
이후에는 클라이언트에서 서버에서 Response된 값을 Parsing 한 후Rendering을 진행하였으며, 
limit과 offset옵션을 QueryString에 추가하여 페이지 네이션을 진행하였습니다.

DAO는 블록체인 기술을 활용해서 자율적으로 운영되는 조직이고 참여자들이 투표를 함으로써 의사결정을 하는데
일반적인 투표 사이트로 기획이 바뀌어서
투표를 할 수 있는 뷰를 만들고 useQuery를 통해 투표 데이터 페칭을 하였고 
투표선택이 완료가 되면 useMutation을 사용해서 제출 기능을 구현하였습니다.

#WebPack ,Rollup의 차이
웹팩과 롤업은 모두 노드 모듈스에서 의존이 있는 모든 모듈을 찾고 병합하고 압축해서 번들된 결과를 얻는 번들링 도구입니다.
웹팩같은 경우는 주로 웹 에플리케이션에서 사용이 되고 롤업은 라이브러리나 패키지를 번들링 하는데 사용이 됩니다.

#프로젝트를 하면서 힘들었던 점
처음에 프로젝트 진행하면서 테스크를 관리 할때 마음만 앞서고 시간에 쫓겨서 우선순위를 잘 정하지 못했는데
주변에 개발자분들과 소통을 하기도 하고 테스크가 밀릴것 같을 때는 늦게까지 업무를 끝내는걸 반복하다보니
조금씩 우선순위가 보이기 시작한것같고 효율도 올라간것 같습니다.

#S3가 뭔가요 써본적 있나요?
S3는 비정형 데이터를 저장할 수 있는 객체 스토리지입니다. 보통 이미지나 비디오의 객체 형태의 파일을 저장 할 수 있습니다.
이전 회사에서는 클라이언트내에서 이미지를 파싱해서 렌더링 업무를 진행했는데요
이때 S3와 AWS Cloud Front를 사용했었습니다. 결과적으로 client에서 이미지를 가져오기 위해서
AWS cloud Front를 사용해서 이미지 파싱 기능을 구현했습니다.

CLoud front 는 aws cdn 서비스인데 로드벨런싱과 네트워크 근접성을 제공해줍니다.

# redux-toolkit 쓰는법
1. index.ts에 configure Store 함수를 사용해서 리덕스 스토어를 생성합니다.
2. 프로바이더 컴포넌트로 감싸서 이를 전역관리해줍니다.
2. createSlice 함수를 사용하여 reducer를 생성합니다. 
createSlice함수는 파라미터에 name, initialState, reducers 이 3개를 작성해주면 됩니다.
reducers: 상태 변화를 처리하는 함수를 정의합니다. 
함수의 이름은 dispatch로 부르는 액션 함수의 이름이며,
 함수 내부는 위와 같이 state의 상태 값을 변경하는 처리를 해줍니다. 
 dispatch에 포함해서 전달한 값은 PayloadAction<>의 타입의 action.payload 값으로 확인할 수 있습니다.
기존의 Redux에서 액션 타입을 지정하고, 타입에 따른 액션 생성함수,
 action.type에 따른 상태 변화 처리 및 불변성 처리를 3단계에 나눠서 했었다면,
  Redux Toolkit에서는 이 하나의 함수를 정의하는 것으로 끝납니다!
4. useSelector 훅을 사용하여 스토어에서 데이터 읽기
dispatch 함수를 useDispatch 훅에서 가져오고 필요에 따라 액션을 전달합니다.

#useQuery, useMutaion ,useQueries,
데이터를 get 하기 위한 api입니다. post, update는 useMutation을 사용합니다.
첫번째 파라미터로 unique Key가 들어가고, 
두번째 파라미터로 비동기 함수(api호출 함수)가 들어갑니다. 
(당연한 말이지만 두번째 파라미터는 promise가 들어가야합니다.)
첫번째 파라미터로 설정한 unique Key는 다른 컴포넌트에서도 해당 키를 사용하면 호출 가능합니다. 
unique Key는 string과 배열을 받습니다. 
배열로 넘기면 0번 값은 string값으로 다른 컴포넌트에서 부를 값이 들어가고
두번째 값을 넣으면 query 함수 내부에 파라미터로 해당 값이 전달됩니다.
return 값은 api의 성공, 실패여부, api return 값을 포함한 객체입니다.
useQuery는 비동기로 작동합니다. 즉, 한 컴포넌트에 여러개의 useQuery가 있다면 
하나가 끝나고 다음 useQuery가 실행되는 것이 아닌 두개의 useQuery가 동시에 실행됩니다. 
여러개의 비동기 query가 있다면 useQuery보다는 밑에 설명해 드릴 useQueries를 권유드립니다.
enabled를 사용하면 useQuery를 동기적으로 사용 가능합니다. 

### CSR vs SSR vs SSG

1. csr은 클라이언트 사이드 렌더링입니다. user의 요청이 있을경우에 
서버로부터 클라이언트는 빈 html과 js를 다운로드 받고 다운이 완료된 js가 실행이 됩니다.
그리고 이 자바스크립트를 통해서 브라우저가 렌더링합니다.
클라이언트 측에서 다운로드를 하기 때문에 초기 렌더속도가 느리다는 단점이 있지만 
뷰 렌더링을 브라우저가 담당시키기 때문에 서버 트래픽을 감소시키고 사용자에게 더 빠른 인터렉션을 제공해줍니다.
2. SSR은 서버사이드 렌더링입니다. 유저의 요청이 있을때 서버에서 즉시 렌더가능한 html을 내려주기 때문에 초기 렌더속도가 빠르고 그로 인해서 검색엔진 크롤러에 더 잘걸려서 seo검색엔진 최적화의 장점이 있습니다.
하지만 유저의 요청이 있을때마다 서버에서 새로운 html을 내려주기 때문에 깜빡임 같은 현상이 발생할 수 있고 서버에 부담을 줍니다.
3. ssg는 스테틱 사이트 제너레이션입니다. 
SSG는 프로젝트 빌드 시에 페이지를 사전 렌더링하는 방식으로 미리 만들어 둔 페이지를 클라이언트에게 제공하므로 렌더링 속도가 매우 빠르다.
SSR과 마찬가지로 완성된 페이지를 클라이언트에게 건네주므로 SEO에도 친화적이다.
블로그, 정보성 페이지 등 정적인 데이터를 보여주는 사이트에 적합하다.


## next ssg 구현 getStaticProps, getStaticPaths (SSG)

html이 빌드타임에 생성됩니다.
빌드할때 데이터를 가져와서 html 을 생성후 사용자의 요청이 들어올때마다 빌드된 html 을 재사용합니다.

아무래도 미리 html파일을 만들어놓고 요청시에 보여주기 때문에 성능적으로 봤을때 빠릅니다.
하지만 데이터가 계속 바뀌어야하는 페이지라면 이 방법은 쓰지 않는게 좋습니다.
내 페이지가 계속 업데이트 되지 않는페이지라면 ? 그때 이 getStaticProps 를 쓰는 것이 좋겠죠.

다이나믹 라우팅을 사용하여 정적페이지를 만들경우에 getStaticProps 를 사용한다면 getStaticPaths와 함께 써주어야 합니다.

## next ssr 구현
1. getServerSideProps (SSR)

getServerSideProps 는 요청할때마다 html이 생성되기 때문에 데이터가 계속 업데이트 됩니다.
요청할때마다 데이터를 계속 불러오는 것이죠.
그래서 데이터를 새로 받아오면 그 데이터로 페이지가 렌더링 됩니다.


page를 사용자가 요청하면 getServerSideProps 를 먼저 실행후 프론트가 서버에 직접요청 후 데이터를 받아와서 page 컴포넌트에 date를 props로 전달하여 렌더링 할 수 있습니다.
getServerSideProps 는 계속 데이터가 바뀌어야하는 페이지의 경우 사용합니다. 

getStaticPaths에서 params에 빌드하고싶은 페이지를 넣어야 해요.
만약 user/[id].js 에 id 값이 1이라면 params에 {id:'1'} 로 넣어주어야 합니다.
즉 빌드할 페이지들을 서버에서 다 가져오서 html 로 뽑아놓겠다는 것이죠.
그런데 만약 미리 빌드한 페이지말고 새로운 페이지 요청이 들어온다? 
이걸 방지

react-query 라이브러리는 React 애플리케이션에서 데이터 fetching을 간편하게 처리할 수 있게 해주는 라이브러리입니다. useMutation은 react-query 라이브러리에서 제공하는 React Hook 중 하나입니다.

useMutation Hook은 API endpoint와 상호작용할 때 POST, PUT, DELETE와 같은 요청을 보내기 위해 사용됩니다. 이 Hook을 사용하면 리액트 애플리케이션에서 mutation에 대한 요청을 보내고, 서버로부터 응답을 받아서 처리할 수 있습니다.

useMutation Hook을 사용하면 다음과 같은 일을 할 수 있습니다.

mutation 함수를 정의하고 호출할 수 있습니다.
mutation 함수의 결과를 처리할 수 있는 함수를 정의하고, 이 함수는 mutation이 성공했을 때 실행됩니다.
react-query가 자동으로 mutation 요청을 관리하고, 필요한 경우 캐싱된 데이터를 업데이트합니다.
useMutaion은 post,pust DELETE를 할 수 있는데요
useQueries처럼 첫번째 인자로 뮤테이션 키를 받고  두번째로는 api 호출 함수 세번쨰는 options가 존재합니다.
